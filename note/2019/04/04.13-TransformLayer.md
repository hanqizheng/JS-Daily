# 2019-04-13 传输层

今天来学习传输层的相关知识

## 传输层到底有什么用？

### 几个概念

我们知道通过`IP协议`，我们就可以完成`两个主机之间的通信`。

可能你会问`两个主机之间的通信`到底是指什么？

我用大白话来简单地描述一下：

比如你打开自己的笔记本电脑，打开浏览器，然后要`访问www.google.com`，所以你输入了www.google.com然后按下了回车。

这时候浏览器当然会通过DNS解析到`www.google.com`这个域名所对应的`ip地址`。然后就向这个IP地址发送了一个Http请求。然后Google收到你的请求会返回一相应的数据，而你先前的请求里携带了`你自身的ip地址`,所以，它会向这个ip地址发送响应的数据。

> 由于我们讨论的是传输层，所以在传输层之上的应用层http协议的相关内容会在后续详细展开，这里先做忽略。

这时候其实就完成了`两个主机之间的通信`。但是这里这个表述其实是不准确的。因为真正在通信的是`运行在你这台笔记本上的浏览器程序`而不是你这台笔记本电脑。而真正接收你请求并作出响应处理的也不是Google的服务器，而是`跑在Google服务器上的程序`。

而我们又知道，`运行的程序其实是在操作系统中的一个进程`，所以我们就可以把这个表述补充完整：

```
通信真正的端点，是主机中跑着的进程

而两主机之间的通信实际上则是两主机进程间的通信
```

那么既然是主机进程间的通信，所以我们就不能忽略掉进程的相关。

**我们知道一个主机是可以有多个进程的**，那么就会出现这种情况：

主机A的若干进程和主机B之间的若干进程进行通信。**这就表明，运输层是有复用和分用功能的**。

这里的`复用`是指在发送方不同的应用进程都可以使用同一个传输层协议进行数据传输

`分用`则是接收方的传输层在剥去报文的首部后能够把这些数据交付到目的进程中。

**如何实现复用和分用的呢？**

### 端口
我们知道在操作系统中有可以标识唯一进程的PID，但是在互联网的大环境下这个不太可行，因为操作系统不止一个，不同的操作系统PID的格式等信息都不统一，这并不能满足任何互联网中的主机都可以通信的需求，所以必须要有一个`统一`的办法。

所以`协议端口号(protocol port number)`随之出现。端口的出现就意味着，虽然目标终点是应用进程，但我们只需要把数据传送到主机对应的端口，剩下的事情则就交给TCP或UDP协议来处理了。

端口号在协议中用16bit表示，所以可以有65535个端口号供协议使用。

## 所以传输层到底有什么用呢？

IP协议的**管辖范围只能是一个主机的ip到另一个主机的ip**，当沿着网线找到ip地址后，`数据并没有到达目的地`，还要被发送到真正需要它的进程中，所以：

```
传输层是为应用程序进程之间提供逻辑通信的
```

这里要解释一下什么是`逻辑通信`：是指看似是直接从这台主机的传输层将数据发向另一台主机的传输层，但其实经历了很多层而不是直接发过去的。所以逻辑通信就是`好像是这样通信，但实际不是`的意思。

## 传输层的协议

### UDP

UDP(User Datagram Protocol)用户数据报协议

UDP的特点：
- `无连接`的，发送之前不需要建立连接，就是我只管发，可能就是扔到了大海，但是我发（扔）出去了，别的我不管。
- UDP使用`尽最大努力交付`，当然，上面那么形容UDP有点不太好，但它确实不会维持复杂的连接状态而费神。
- UDP是`面向报文`的。也就是`应用层`传下来一个什么样的报文，UDP都会**原封不动**，只是加个头部就发给网络层了，所以应用层必须让报文的长度适中，太长或太短都会影响网络层的效率。
- `没有拥塞控制`。拿到加个头部就发出去了，不会消耗太多时间，所以不太可能拥塞。
- 支持一对一，一对多，多对一，多对多交互通信
- UDP`首部开销相对较小`只有8个字节。TCP有20个字节。

```
// UDP伪首部
--------------------------------------
|     4    |     4    | 1 | 1 |   2  |
--------------------------------------
|   源IP   |   目标IP | 0 | 17|UDP长度|
--------------------------------------

// UDP首部
--------------------------------------
|   2    |      2   |   2   |   2    |
--------------------------------------
| 源port | 目标port |  长度  |  校验和 |
--------------------------------------
```

伪首部会加在首部前

**如果接收方UDP发现收到的报文中端口号不正确，则直接丢弃**

> 传输层还有差错检测的功能，和网络层差错检测有类似也有不同，会单独拿出一节来讲，这里就先忽略掉这部分内容。

### TCP

相比UDP，TCP就显得有点复杂了。

TCP(Transmission Control Protocol)传输控制协议

> TCP的复杂表现在可靠传输，流量控制和拥塞控制这几个方面，但是这里不会展开讲的很详细，我可能在这里只会简单的介绍TCP的头部格式以及建立连接的相关内容。

TCP的主要特点：
- TCP是面向连接的。也就是说在使用TCP传输数据之前要先与对方建立连接，在确认连接成功之后才会开始传输信息。
- TCP每次连接只能有两个端点(endpoint)，也就是说`每个TCP的连接只能是一对一的`。
- TCP提供`可靠交付`的服务，相比UDP扔出去不管，TCP是要保证数据一定能让对方收到的。
- TCP是全双工通信。TCP允许双方进程任何时间都能给对方发送数据。
- TCP是面向字节流的。TCP不知道应用层交给他的数据到底是什么。他会把数据分成若干个数据块（长度不等）发送出去，然后只要保证对方能按顺序接收到这几个数据块然后再组装在一起，就能确定数据可以还原回去。



上面有提到`TCP每次连接只能有两个端点(endpoint)`,那这个端点是什么呢？

**这个端点不是端口，也不是进程，而是socket(套接字)**。

```
socket = (ip地址:端口号)

// 10.10.98.10:8080
```
**所以，每一条TCP连接被唯一的两个socket确定！即：**
```
TCP连接 ::= { socket1, socket2 } = { (IP1:port1), (IP2:port2) }
```

### socket的歧义

发展到现在的互联网，东西越来越多，socket这个词有了很多含义，很容易混淆

- 表示介于传输层和应用层之间的接口API，叫做socket API
- socket API中的一个函数也叫socket
- 还有一些但不常用。。。

### 头部格式

![](/source/image/tcp_header.png)

- 源端口和目标端口没什么特殊的，是为了TCP协议进程间通信所存在
- 序号，占4字节。我们之前说过`TCP是面向字节流`的，所以TCP要传输的数据会以字节为单位`顺序编号`。然后我又说过TCP会将数据分成若干`数据块`分开发送，所以这个序号就是用来表明`本次数据的起始数据字节是第几个`。
- 确认号，4字节。表示期望的`下一个数据块起始字节的编号`，现在就明白是用来确认传输是否正确，按顺序的。而且这里要注意一点，**假如确认号为N,则表示N-1为止所有的数据都已经正确收到。**
- 数据偏移，1字节，是用来指出TCP`整个报文的起始位置`和`数据的起始位置`相差多少。
- 保留，6`位`，后续使用
- URG(urgent),紧急字段标识符，当URG = 1时，表明本次传输的数据是紧急数据，`可以不排队尽快发送`。
- ACK(acknowlagedment)，确认标识符，当ACK = 1 时这个字段才表示有效，在三次握手的时候用到
- PSH(push)，推送标识符，推送时为了`尽快获取到回应`而设置的，回应的数据要积累够一定的数量才会一并发送回请求方，但是如果PUS = 1时，则可以直接回应不用等到一定量。
- RST(reset)，复位标识符，RST = 1 说明TCP的本次连接出现了`严重的差错`,必须断开重连。
- SYN(synchronization)，同步标识符，是三次握手时要用到的标识符。
  * 当SYN = 1 && ACK = 0时，表示正处在请求连接的阶段，如果对方响应，则会把ACK置1。后面讲握手会讲到。
- FIN(finish)，终止标识符。当FIN = 1时，表示要释放本次TCP连接。
- 窗口，2字节，**窗口之是经常动态变化的，给出了接收方还能再接收多少字节的数据量**。
- 校验和，2字节，这一个和UDP一样用于传输校验。
- 紧急指针，2字节，只有当URG = 1时才有意义，指出`本次紧急数据的字节数`.
- 选项，长度可变。

可以看出TCP头部的最小长度时20字节。

### 3次握手

### 为什么要握三次手？

[为什么要握3次手，而不是两次，或者4次呢？](https://hanqizheng.github.io/2019/01/30/TCPHandshake/)

### 连接

#### 连接建立，也就是三次握手！

连接的建立需要满足下面三个需求：
- 需要让双方都确定对方的存在
- 允许双方协商一些参数（比如窗口值之类的）
- 连接能够运输实体资源（如缓存大小，连接表中的项目等）

建立的过程:

![](/source/image/tcp_handshake.jpg)
其实简单的来说就是**要让双方都发一次ACK置1的报文**

但是怎么区分开始建立这个动作，所以需要SYN这个字段的帮助。

- 第一次握手，客户端发一个SYN = 1 的报文给服务端
- 第二次握手，服务端收到了这个报文，所以要回应，于是发送给客户端一个ACK = 1, SYN = 1的报文。
- 第三次握手，客户端收到了服务端的回应，需要再通知服务端一遍我确实收到了你的回应，那么我们开始传数据吧。所以再发往服务端一个ACK = 1的报文。

#### 连接释放，也就是4次挥手

![](/source/image/tcp_close.png)

道理和建立连接时类似，而这次标记断开连接开始和结束的时FIN字段
- 第一次挥手，客户端表示不想跟你服务端玩了，于是发送了分手报文，其中FIN = 1，翻译成汉语就是我们分手吧。
- 第二次挥手， 服务端收到分手信很难受，但也有点生气，于是很气的`立即`发了一个回应的分手信，说ACK = 1(我收到你的分手信了)，你等着，我也写分手信！然后它发出去以后就开始着手写分手信。
- 第三次挥手，服务端写完分手信觉得很满意，于是发向了客户端。而信的内容是FIN = 1, ACK = 1。翻译过来就是：我们分手吧，这是你的东西（其实就是先前可能客户端发了一些请求，发完就准备关闭连接，但这个时候服务端还没有处理这些请求，所以在服务端关闭连接之前要先处理完那些请求。），我也一并邮寄给你了，拜拜。
- 第四次挥手，客户端收到了服务端的分手信，告诉服务端，ok，我收到了。也就是ACK = 1。

从此，连接关闭了。